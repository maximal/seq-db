# SeqQL

## Полнотекстовый поиск

Полнотекстовый поиск в SeqQL позволяет фильтровать результат по токенам документов.
Запросы могут содержать точные фразы или ключевые слова, разделенные пробелами.
Это поведение зависит от типа индекса, подробнее о формировании токенов смотрите [виды индексов](docs/index.md).
При выполнении полнотекстового поиска система автоматически отбирает результаты, соответствующие
заданному тексту.

По умолчанию поиск не чувствителен к регистру.
Это конфигурируется с помощью параметра `--case-sensitive` и влияет только на новые документы.

## Логические операторы

SeqQL поддерживает логические операторы для более точного фильтра поиска. Операторы `and`, `or`, `not` позволяют
комбинировать и усложнять запросы:

- `and` — используется для поиска, где оба условия должны быть истинными.
- `or` — возвращает результаты, если одно из условий выполняется.
- `not` — исключает результаты, соответствующие указанному условию.

Примеры:

```plaintext
message:error and level:critical
message:login or message:logout
not level:debug
```

## Подстановочные символы

Wildcards, или "подстановочные символы", в SeqQL позволяют производить поиск по частичному совпадению.
Язык поддерживает следующие символы:

- `*` — заменяет любое количество символов.

Эти символы можно использовать для поиска на уровне отдельного токена или его части.
Например, запрос [keyword](index.md#keyword) индекса `source_type:access*`
найдет все документы, начинающиеся с `access`.

## Range

SeqQL позволяет использовать диапазоны значений (range) для фильтрации данных. Это особенно полезно для числовых
значений, таких как размеры или время. Диапазоны задаются с использованием квадратных или круглых скобок:

- `[a, b]` — включает границы диапазона.
- `(a, b)` — исключает границы диапазона.

Пример использования диапазона:

```plaintext
bytes:(100, 1000]
bytes:[100, 1000)
```

## Pipes

Pipes в SeqQL — это механизм для последовательной обработки данных после
стадии [первичной фильтрации](#полнотекстовый-поиск).
Pipes позволяют трансформировать, обогащать, фильтровать, агрегировать данные и форматировать результаты.

Pipes в SeqQL делятся на три основных группы:

1. **Обогащающие и фильтрующие pipes**
2. **Агрегационные pipes**
3. **Форматирующие pipes**

### Обогащающие и фильтрующие pipes

Эти pipes выполняют операции на уровне индекса, добавляя новые данные или отбирая информацию по определенным критериям.
Они обогащают исходные записи, создавая новые поля или изменяя существующие.

Примеры:

- `eval` — вычисляет значение выражения и создает новое поле.
- `where` — фильтрует данные по заданному условию.
- `limit` — ограничивает количество возвращаемых результатов.

#### `where` pipe (в разработке)

Pipe `where` выполняет фильтрацию на уровне индекса. Он используется для ограничения результатов, соответствующих
определенному условию.

Пример:

```plaintext
source_type:access* | eval KB=bytes/1024 | where KB>100
```

В этом примере Pipe `eval` создает поле `KB`, а Pipe `where` ограничивает результаты теми, где `KB` больше 100.

### Агрегационные pipes (в разработке)

Агрегационные pipes используются для выполнения статистических операций и агрегирования данных. Они позволяют
производить подсчеты, вычислять суммы, средние значения и другие статистические показатели.

Примеры:

- `stats` — агрегирует данные по заданному методу (например, `count`, `sum`, `avg`).
- `topK` — находит наиболее частые значения.

#### `count` pipe (в разработке)

Pipe `count` подсчитывает количество записей, соответствующих заданному критерию, и часто используется с другими
агрегационными pipes для группировки данных.

Пример:

```plaintext
source_type:access* | stats count by user
```

В данном примере производится подсчет количества записей для каждого пользователя.

### Форматирующие pipes

Форматирующие pipes позволяют изменить представление результата поиска после выполнения всех фильтраций и агрегаций. Они
работают с итоговыми данными, отбирая или исключая определенные поля, сортируя и упорядочивая результаты.

#### `remove` pipe

Pipe `remove` удаляет у документа перечисленные через запятую поля.
Это может пригодиться, когда нужно убрать лишние поля из результата,
также это особенно полезно при экспорте большого числа данных.

Перечисленные поля могут не входить в [mapping](mapping.md)
и их наличие не влияет на производительность `remove` pipe.

Пример:

```seq-ql
source_type:access* | remove remote_addr, message, http_code 
```

В этом примере поля `remove_addr`, `message`, `http_code` будут исключены из результата.

См. [fields](#fields-pipe) pipe если нужно оставить только указанные поля.

#### `fields` pipe

Pipe `fields` оставляет у документа только перечисленные через запятую поля.
Это может пригодиться, когда нужно оставить только нужные поля,
также это особенно полезно при экспорте большого числа данных.

Перечисленные поля могут не входить в [mapping](mapping.md)
и их наличие не влияет на производительность `fields` pipe.

Пример:

```plaintext
source_type:access* | fields user, KB
```

Здесь в итоговом результате будут только поля `user` и `KB`.

См. [remove](#remove-pipe) pipe если нужно удалить только часть полей.

## Рекомендации по оптимизации запросов в SeqQL

Оптимизация запросов в SeqQL позволяет эффективно обрабатывать большие объемы данных и получать нужные результаты
быстрее, снижая нагрузку на систему.
Основная цель оптимизации заключается в минимизации объема обрабатываемых данных на каждом этапе обработки.

Ниже перечислены ключевые рекомендации для оптимизации запросов SeqQL:

### Максимальная фильтрация на стадии первичного поиска

При составлении запроса старайтесь отфильтровать как можно больше данных на уровне первичного
поиска. Уточняйте условия поиска, задавая конкретные поля (например, `source_type`, `status`, `date`), чтобы
отсеять ненужные данные и сократить их объем перед обработкой пайпами.
Например, использование более узкого диапазона значений, таких как временные интервалы или точные значения для
индексов, например, `source_type:access* AND date:[2023-01-01, 2023-12-31]`, отсекает нерелевантные данные до
дальнейшей обработки.

### Сокращение возвращаемых полей

Указывайте только те поля, которые вам нужны, чтобы уменьшить объем данных и ускорить обработку
запроса.
Используйте форматирующий пайп `fields`, чтобы выбрать только важные поля:

```
source_type:access* | eval KB=bytes/1024 | where KB > 100 | fields KB, status, timestamp
```

Здесь итоговый результат включает только указанные поля `KB`, `status` и `timestamp`, что экономит память и
уменьшает время вывода результатов.

### Ограничение количества записей

Если вам нужно лишь определенное количество записей, используйте `limit` на этапе фильтрации. Это
остановит обработку после достижения необходимого количества записей, экономя ресурсы.
Применение ограничения через `limit`, чтобы избежать обработки всех доступных данных:

```seqql
source_type:access* | where status:200 | limit 100
```

Этот запрос вернет только первые 100 записей, соответствующих условиям, что сократит время обработки запроса.

## Распространенные ошибки в SeqQL

### `pipe ... cannot be after pipe ...`

Ошибка вида `pipe ... cannot be after pipe ...` возникает, когда вы пытаетесь вернуться на предыдущую стадию обработки
пайпа. Это может быть из-за неправильного порядка использования пайпов в вашем запросе.

Пример:

```plaintext
source_type:access* | fields message | where login:admin
```

– данный запрос вернет ошибку `pipe "where" cannot be after pipe "fields"`.
Правильное использование:

```plaintext
source_type:access* | where login:admin | fields message 
```

Подробнее про стадии обработки SeqQL см. [Pipes](index.md#pipes).
